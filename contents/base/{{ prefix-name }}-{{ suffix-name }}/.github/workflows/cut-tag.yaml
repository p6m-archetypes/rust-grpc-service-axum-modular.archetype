name: Tag & Release

on:
  workflow_dispatch:
    inputs:
      version-level:
        description: "Version bump level"
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: patch

permissions: write-all

run-name: Cut ${{'{'}}{ inputs.version-level }} tag by @${{'{'}}{ github.triggering_actor }}

env:
  IMAGE_NAME: github-adapter-server
  APPLICATION_NAME: github-adapter

jobs:
  # ===========================================================================
  # Pre-build: Version bump, test, and prepare for parallel builds
  # ===========================================================================
  pre-build:
    name: Pre-build
    runs-on: ubuntu-latest
    outputs:
      version: ${{'{'}}{ steps.cut-tag.outputs.version }}
      tag: ${{'{'}}{ steps.cut-tag.outputs.tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Rust
        uses: p6m-actions/rust-setup@v1
        with:
          components: clippy, rustfmt

      - name: Login to Cargo Registry
        uses: p6m-actions/rust-registry-login@v1
        with:
          cargo-tokens: |
            ${{'{'}}{ vars.CARGO_REGISTRY }}=${{'{'}}{ secrets.ARTIFACTORY_IDENTITY_TOKEN }}

      - name: Cut Tag
        id: cut-tag
        uses: p6m-actions/rust-cut-tag@v1
        with:
          version-level: ${{'{'}}{ inputs.version-level }}
          workspace: true

      - name: Ensure Changes are Pushed
        run: |
          TAG="${{'{'}}{ steps.cut-tag.outputs.tag }}"
          echo "Pushing version bump commit and tag ${TAG} to remote..."
          git push origin HEAD --force-with-lease
          git push origin "${TAG}" --force

      - name: Build and Test
        uses: p6m-actions/rust-build@v1
        with:
          run-lint: false
          run-format-check: false
          run-test: true
          run-build: false
          workspace: true

  # ===========================================================================
  # Parallel Docker builds - Native architecture builds
  # ===========================================================================
  build-docker:
    name: Build Docker (${{'{'}}{ matrix.arch }})
    needs: [pre-build]
    strategy:
      fail-fast: true
      matrix:
        include:
          - arch: amd64
            runner: ubuntu-latest
            platform: linux/amd64
          - arch: arm64
            runner: ubuntu-24.04-arm
            platform: linux/arm64
    runs-on: ${{'{'}}{ matrix.runner }}
    outputs:
      amd64-digest: ${{'{'}}{ steps.docker-publish.outputs.amd64-digest }}
      arm64-digest: ${{'{'}}{ steps.docker-publish.outputs.arm64-digest }}
    env:
      VERSION: ${{'{'}}{ needs.pre-build.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{'{'}}{ needs.pre-build.outputs.tag }}

      - name: Login to Docker Repository
        uses: p6m-actions/docker-repository-login@v1
        with:
          registry: ${{'{'}}{ vars.ARTIFACTORY_HOSTNAME }}
          username: ${{'{'}}{ secrets.ARTIFACTORY_USERNAME }}
          password: ${{'{'}}{ secrets.ARTIFACTORY_IDENTITY_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Docker Image
        id: docker-build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: .platform/docker/prd/Dockerfile
          platforms: ${{'{'}}{ matrix.platform }}
          push: true
          tags: ${{'{'}}{ vars.ARTIFACTORY_HOSTNAME }}/${{'{'}}{ vars.ARTIFACTORY_PROJECT }}-docker-local/applications/${{'{'}}{ env.IMAGE_NAME }}:${{'{'}}{ env.VERSION }}-${{'{'}}{ matrix.arch }}
          secrets: |
            ybor-studio=Bearer ${{'{'}}{ secrets.ARTIFACTORY_IDENTITY_TOKEN }}
          cache-from: type=gha,scope=${{'{'}}{ matrix.arch }}
          cache-to: type=gha,mode=max,scope=${{'{'}}{ matrix.arch }}
          provenance: false
          sbom: false

      - name: Output Digest
        id: docker-publish
        run: |
          echo "${{'{'}}{ matrix.arch }}-digest=${{'{'}}{ steps.docker-build.outputs.digest }}" >> $GITHUB_OUTPUT

  # ===========================================================================
  # Publish crates (parallel with Docker builds)
  # ===========================================================================
  publish-crates:
    name: Publish Crates
    needs: [pre-build]
    runs-on: ubuntu-latest
    env:
      VERSION: ${{'{'}}{ needs.pre-build.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{'{'}}{ needs.pre-build.outputs.tag }}

      - name: Setup Rust
        uses: p6m-actions/rust-setup@v1

      - name: Login to Cargo Registry
        uses: p6m-actions/rust-registry-login@v1
        with:
          cargo-tokens: |
            ${{'{'}}{ vars.CARGO_REGISTRY }}=${{'{'}}{ secrets.ARTIFACTORY_IDENTITY_TOKEN }}

      - name: Publish to Cargo Registry
        uses: p6m-actions/rust-registry-publish@v1
        with:
          registry: ${{'{'}}{ vars.CARGO_REGISTRY }}
          from-git: true

  # ===========================================================================
  # Post-build: Create manifest, release, and deploy
  # ===========================================================================
  post-build:
    name: Post-build
    needs: [pre-build, build-docker, publish-crates]
    runs-on: ubuntu-latest
    env:
      VERSION: ${{'{'}}{ needs.pre-build.outputs.version }}
      TAG: ${{'{'}}{ needs.pre-build.outputs.tag }}
    steps:
      - name: Login to Docker Repository
        uses: p6m-actions/docker-repository-login@v1
        with:
          registry: ${{'{'}}{ vars.ARTIFACTORY_HOSTNAME }}
          username: ${{'{'}}{ secrets.ARTIFACTORY_USERNAME }}
          password: ${{'{'}}{ secrets.ARTIFACTORY_IDENTITY_TOKEN }}

      - name: Create and Push Multi-arch Manifest
        id: manifest
        run: |
          REGISTRY="${{'{'}}{ vars.ARTIFACTORY_HOSTNAME }}/${{'{'}}{ vars.ARTIFACTORY_PROJECT }}-docker-local/applications"
          IMAGE="${REGISTRY}/${{'{'}}{ env.IMAGE_NAME }}"

          # Create manifest combining both architectures
          docker manifest create ${IMAGE}:${VERSION} \
            ${IMAGE}:${VERSION}-amd64 \
            ${IMAGE}:${VERSION}-arm64

          # Push the manifest and capture the digest from output
          DIGEST=$(docker manifest push ${IMAGE}:${VERSION})
          echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
          echo "Multi-arch manifest digest: ${DIGEST}"

      - name: Create Digest Artifact
        run: |
          echo '${{'{'}}{ steps.manifest.outputs.digest }}' | tee digest.txt

      - name: Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          name: Version ${{'{'}}{ env.VERSION }}
          tag: ${{'{'}}{ env.TAG }}
          makeLatest: true
          artifacts: "digest.txt"
          removeArtifacts: true
          generateReleaseNotes: true
          body: |
            Application version: `${{'{'}}{ env.VERSION }}`
            Docker image digest: `${{'{'}}{ steps.manifest.outputs.digest }}`

      - name: Update Application Manifest
        uses: p6m-actions/platform-application-manifest-dispatch@v1
        with:
          repository: ${{'{'}}{ github.repository }}
          image-name: ${{'{'}}{ env.APPLICATION_NAME }}
          environment: "prd"
          digest: ${{'{'}}{ steps.manifest.outputs.digest }}
          update-manifest-token: ${{'{'}}{ secrets.UPDATE_MANIFEST_TOKEN }}
          platform-dispatch-url: ${{'{'}}{ vars.PLATFORM_DISPATCH_URL }}
          directory-name: ${{'{'}}{ env.APPLICATION_NAME }}
